04 도커 컴포즈
4.1 사용 이유
1개의 어플리케이션을 구동하기 위해 복수개의 컨테이너가 필요한 경우 ex)웹서버 + db 
여러개의 컨테이너를 묶어 하나의 서비스로 정의 하여 관리하면 좋겠지…
> 여러개의 컨테이너의 옵션 및 환경 설정 파일을 읽어 컨테이너를 순차적으로 생성하는 방식으로 동작함.
4.2 도커 컴포즈 설치
설치..
4.3 도커 컴포즈 사용
4.3.1 기본 사용법
yaml 파일에 컨테이너 설정 정의 > 해당 파일을 읽어 컨테이너를 생성하기 때문에 컴포즈 사용을 위해 1순위 할일
4.3.1.1 docker-compose.yml 작성

추가 설정이 없는 경우 디렉터리에 docker.compose.yml 파일을 기본으로 읽어서 엔진에 생성 요청을 보낸다. 
추가로 이름을 명시하지 않는 경우 현 디렉토리 이름 기준으로 네이밍 생성
>docker-compose up -d 명령어를 통해 컨테이너를 생성하면 출력결과도 확인 가능

4.3.1.2 도커 컴포즈의 프로젝트, 서비스, 컨테이너
컴포즈에서 컨테이너는 프로젝트 및 서비스단위로 구분됨
일반적 네이밍 [프로젝트이름]_[서비스이름]_[서비스내 컨테이너 번호]

서비스내 여러 컨테이너가 존재하므로 번호로 구별
하나의 yml로 특정 서비스 컨테이너만 생성할수도 있다. 
>docker-compose up -d [서비스]
>docker-compose run web /bin/bash
scale 명령어로 컨테이너 조정 가능. 
down명령어 사용시 프로젝트 삭제 (서비스 컨테이너 전체 정지 후 삭제)
기본 현재 디렉터리 이름으로 된 프로젝트 제어
-p 옵션으로 명시한 경우 프로젝트 이름 제어 가능 > 같은 yml로 여러개의 프로젝트 생성가능.
4.3.2 도커 컴포즈 활용
4.3.2.1 yaml 파일 작성
버전정의 / 서비스정의 / 볼륨정의 / 네트워크 정의 로 구분
기본 현재 혹은 상위 디렉토리에서 docker-compose.yml 파일을 찾지만 -f 옵션으로 특정 파일 지정도 가능.
버전정의
1,2,2.1,3 버전이 있음. 버전 3이 도커 컴포즈 버전 1.10에서 사용할수 있으며 도커 스웜모드와 호환되므로 3을 쓰는 편이 좋다
version : ‘3.0’ 으로 씀
서비스정의
도커 컴포즈로 생성할 컨테이너 옵션 정의
각 서비스 별로 컨테이너로 구현, 하나의 프로젝트로 관리됨.
services:
  my_container_1: (앞에 스페이스바 2개를 넣어 하위 항목임을 명시)
    image: 컨테이너 생성에 쓰일 이미지 이름 (docker run과 같은 포맷)
    links: docker run –link와 동일 다른서비스에 서비스 명만으로 접근가능하도록 설정
    enviroment: docker run -e(nv) 옵션. 환경 변수 지정
    command: 실행시 수행 명령어. 
    depends_on: 특정 컨테이너와의 의존관계. 해당 항목에 명시된 컨테이너 생성 후 실행( 서비스 이름으로만 접근) 단, 준비상태를 확인하진 않음. 준비상태까지 확인하려면 entrypoint 등으로 추가 설정 필요

    ports: -p 옵션과 동일. 개방 포트 설정(단 호스트의 특정 포트를 서비스에 연결하면 scale명령어로 컨테이너 수 확장이 불가능함)
    build: 정의된 dockerfile에서 이미지를 빌드해 컨테이너를 생성 (해당 옵션으로 프로젝트 생성 후 Dockerfile을 변경하는 경우, 이후 다시 프로젝트를 생성해도 이미지를 재빌드 하지 않음. 컨테이너 생성시마다 빌드 옵션을 적용하려면 
>docker-compose up -d –build 로 설정 추가
    extends:다른 yml 로부터 서비스 속성을 상속받도록 함   
  my_container_2:
네트워크 정의
driver: bridge가 아닌 다른 네트워크를 사용하도록 설정 할때 driver_ops로 전달

ipam: ip Address Manager subnet, ip범위등을 설정
external: 프로젝트 생성시 기존의 네트워크를 활용하도록 함 (위 옵션들과 함께 쓸수 없음) 
볼륨 정의
driver : 볼륨생성시 사용될 드라이버 정의(없으면 local로 설정) 프로젝트 마다 볼륨 생성
external: 기존 볼륨을 사용하도록 설정
YAML 파일 검증하기
docker-compose config 오타 검사 및 파일 포맷 적절성 검사
4.3.2.2 도커 컴포즈 네트워크
기본 네트워크 정의가 없는 경우 브리지 타입으로 네트워크 생성 [프로젝트 이름]_default 로 설정. 
서비스 내 컨테이너는 –net-alias 가 서비스의 이름을 갖도록 자동 설정. 네트워크에 속한 컨테이너는 서비스 이름으로 서비스내 컨테이너에 접근 가능

4.3.2.3. 도커 스웜 모드와 함께 사용하기.
스택 : yaml 파일에서 생성된 컨테이너의 묶음.
yaml 파일로 스택을 생성하는 경우 파일에 정의된 서비스가 스웜모드 클러스터 에서 일괄 생성됩니다. = 스웜모드의 서비스
단 스택은 docker stack으로 제어함 (스웜모드 클러스터의 매니저에 의해 생성되므로)

스택 사용하기
 

이름을 지정하여 스택 생성
이 경우 컨테이너 간 의존성을 정의하는 옵션은 사용 할수없음.

docker stack ps [스택이름] 
으로 내부 생성 컨테이너 상태까지 확인 가능

스택으로 생성된 서비스 = 스웜모드에서 사용된 서비스 이므로
 docker service ls 
docker stack services [스택이름]
두 명령어 모두 같은 결과를 반환

단 스택은 스웜 킷에 의해 생성되므로 docker service scale을 사용하여 수를 조절해야함.
docker service rm [스택이름]으로 삭제

스택 네트워크
creating network mystack_default < 이라는 출력 결과가 있었다면 자동 생성이 된것
기본 overlay로 scope swarm으로 생성되므로 일반 컨테이너는 이 네트워크를 사용할수 없음.

4.4 도커 학습을 마치며
도커 내부 구조와 컨테이너 생태계의 이해
2016 - 컨테이너 기술이 특정 벤더, 또는 회사 의존적으로 개발되지 않도록 표준을 정의하는 OCI 발표 (런타임 및 이미지 스펙 표준 정의)

도커는 runC, cotanierd, 도커 엔진으로 분리.
도커 데몬(dockerd)는 컨테이너가 아님. 컨테이너 1:1 매핑은 runC가 담당. 
해당 runC 여러개의 프로세스 및 이미지를 관리하는 주체가 containerd
우리가 접하는 도커 엔진은 containerd와 통신하여 runC를 사용할수 있도록 전달하는 엔드 유저용 도구임

컨테이너를 생성하고 사용하는데 꼭 도커가 있어야 하는것은 아니며 runC와 containerd는 도커 엔진 없이도 독립 사용이 가능하다.

위 두 종류 외에도 다양한 컨테이너 kata, firecracker 등이 존재하며, containerd 에 해당하는 cri-o, podman등이 존재 하므로 도커가 가장 많이 사용될뿐 이것만 써야 하는 것은 아니다.


 
