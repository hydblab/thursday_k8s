# 4주차 이태화 자료

## 5. 쿠버네티스 설치

- 도커 컨테이너, 도커 스웜, 도커 컴포즈와 같은 개념을 한군데로 모아 사용할 수 있는 프로젝트: 쿠버네티스
- 주의 사항
  - 타 오케스트레이션 툴보다 다양한 지식을 필요로 함
  - 따라서 쿠버네티스 자체의 관리가 더욱 어려울 수도 있음.
  - 즉, 조직의 규모에 따라 오버 엔지니어링이 될 수 있으니, 운영/관리의 인력과 비용을 고려하여 도입 필요.

### 5.1 쿠버네티스 설치 환경의 종류

- 개발 용도: Minikube, Docker Desktop for Mac/Windows에 내장된 쿠버네티스
  - standalone 모드로 사용하기 때문에 모든 기능을 학습하기에는 어려움
- 서비스 테스트 또는 운영 용도: kops, kubespray, kubeadm, EKS(AWS), GKE(Google)
  - AWS, GKE와 같은 클라우드 플랫폼 활용
  - 또는 on-premise 환경을 활용

![쿠버네티스 설치 도구 및 서비스와 특징 비교](./assets/img1.png?raw=true)

### 5.2 쿠버네티스 버전 선택

- 버전이 관계는 없으나, 너무 최신이거나 너무 예전 버전을 사용하지 않으면 좋음

### 5.3 개발 용도의 쿠버네티스 설치

#### 5.3.1 Docker Desktop for Mac / Windows에서 쿠버네티스 사용

- Kubenernetes 탭에서 활성화

![Docker Desktop for Mac에서 쿠버네티스 활성화](./assets/img2.png?raw=true)

#### 5.3.2 Minikube로 쿠버네티스 설치

- 앞서 설명한 대로, 기능을 간단히 사용해볼 수는 있지만, 실제 운영 환경에서는 Minikube를 적용하기 힘듬
- 가능하다면 여러 대의 서버로 쿠버네티스 클러스터를 구성하는 것이 좋음

##### 기본 설정을 이용해 버추어 박스로 minikube 설치

- 생략

##### 리눅스 서버에서 가상 머신 없이 도커 엔진만으로 minikube 설치

- 참고: <https://minikube.sigs.k8s.io/docs/start/>
- Minikube 설치 (root 사용자로 실행하기 위해서는 --force를 활성화 해야 함)

```bash
[root@lahdev ~]# curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 89.3M  100 89.3M    0     0  28.4M      0  0:00:03  0:00:03 --:--:-- 28.4M
[root@lahdev ~]# sudo install minikube-linux-amd64 /usr/local/bin/minikube
[root@lahdev ~]# minikube start --force
* Centos 8.4.2105 의 minikube v1.32.0
! minikube skips various validations when --force is supplied; this may lead to unexpected behavior
* 자동적으로 docker 드라이버가 선택되었습니다. 다른 드라이버 목록: ssh, none
* The "docker" driver should not be used with root privileges. If you wish to continue as root, use --force.
* If you are running minikube within a VM, consider using --driver=none:
*   https://minikube.sigs.k8s.io/docs/reference/drivers/none/
* Using Docker driver with root privileges
* minikube 클러스터의 minikube 컨트롤 플레인 노드를 시작하는 중
* 베이스 이미지를 다운받는 중 ...
* 쿠버네티스 v1.28.3 을 다운로드 중 ...
    > preloaded-images-k8s-v18-v1...:  403.35 MiB / 403.35 MiB  100.00% 31.03 M
    > gcr.io/k8s-minikube/kicbase...:  453.90 MiB / 453.90 MiB  100.00% 28.68 M
...중략
* 끝났습니다! kubectl이 "minikube" 클러스터와 "default" 네임스페이스를 기본적으로 사용하도록 구성되었습니다.
```

- kubectl 설치: [Kubectl Installation](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/)
- 설치 확인

```bash
[root@lahdev ~]# kubectl get po -A
NAMESPACE     NAME                               READY   STATUS    RESTARTS      AGE
kube-system   coredns-5dd5756b68-wx5pw           1/1     Running   0             48s
kube-system   etcd-minikube                      1/1     Running   0             61s
kube-system   kube-apiserver-minikube            1/1     Running   0             61s
kube-system   kube-controller-manager-minikube   1/1     Running   0             61s
kube-system   kube-proxy-vr8rj                   1/1     Running   0             48s
kube-system   kube-scheduler-minikube            1/1     Running   0             61s
kube-system   storage-provisioner                1/1     Running   1 (18s ago)   59s
[root@lahdev ~]#
```

### 5.4 여러 서버로 구성된 쿠버네티스 클러스터 설치

- 실제 설치 과정은 책을 참고 하는 것이 좋을 것 같음
- 주의 사항과 알아야할 것 들에 대해서만 정리

#### 사전 고려 사항

- 모든 서버의 시간이 NTP를 통해 동기화 되어있는지 확인
  - 네트워크가 불가능한 상황이라면 클러스터 중 한 노드에 ntp server를 구성하고 동기화하는 것도 방법이 될 것 같음 (주)
- 모든 서버의 맥(MAC) 주소가 다른지 확인
- 모든 서버의 하드웨어 스펙 확인: 2GB 메모리, 2 CPU
- 모든 서버에서 메모리 스왑(Swap)을 비활성화
  - 당연히 스왑을 꺼놓게 되면 out of memory(OOM Kill)이 발생할 수 있기 때문에 서버를 쿠버네티스 노드 외 용도로 사용하면 안 될 것 같음 (주)

```bash
[root@lahdev ~]# swapoff -a 
```

## 6. 쿠버네티스 시작하기

### 6.1 쿠버네티스를 시작하기 전에

- 모든 리소스는 "오브젝트"로 관리됨 (우리가 알고있는 추상적인 개념 그대로 이해하면 됨)
  - 스웜 모드에서 서비스라는 것을 사용해서 컨테이너의 묶음을 표현
  - 이 "서비스"도 컨테이너 리소스의 집합을 정의한 것 => 오브젝트
- 쿠버네티스에서의 예시
  - 컨테이너의 집합: Pods
  - 컨테이너 집합을 관리하는 컨트롤러: Replica Set
  - 사용자: Service Account
  - 노드: Node
  - 전부 오브젝트로 사용할 수 있음

- 오브젝트 종류 확인

```bash
[root@lahdev ~]# kubectl api-resources
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
bindings                                       v1                                     true         Binding
componentstatuses                 cs           v1                                     false        ComponentStatus
configmaps                        cm           v1                                     true         ConfigMap
endpoints                         ep           v1                                     true         Endpoints
events                            ev           v1                                     true         Event
limitranges                       limits       v1                                     true         LimitRange
namespaces                        ns           v1                                     false        Namespace
nodes                             no           v1                                     false        Node
persistentvolumeclaims            pvc          v1                                     true         PersistentVolumeClaim
persistentvolumes                 pv           v1
...중략
```

- 처음보는 오브젝트라면 explain으로 간단한 설명을 확인할 수 있음

```bash
[root@lahdev ~]#  kubectl explain pod
KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion   <string>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
...중략
```

- kubectl을 통해 명령어로 실행할 수 있지만, 대부분 YAML 파일을 더 많이 사용
- 즉, 쿠버네티스를 잘 사용하는 것 => YAML 파일을 잘 작성하는 것

#### 쿠버네티스는 여러 컴포넌트로 구성됨

- 쿠버네티스 노드는 마스터와 워커로 구분
  - 마스터 노드는 클러스터를 관리하는 역할
  - 워커 노드는 애플리케이션 컨테이너가 생성
- 마스터 노드에서는 kube-apiserver, kube-controller-manager, kube-scheduler 등 여러 컴포넌트가 실행되고 있음

```bash
[root@lahdev ~]# docker ps
CONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS        PORTS                                                                                                                                  NAMES
90d961e23173   gcr.io/k8s-minikube/kicbase:v0.0.42   "/usr/local/bin/entr…"   24 hours ago    Up 24 hours   127.0.0.1:49157->22/tcp, 127.0.0.1:49156->2376/tcp, 127.0.0.1:49155->5000/tcp, 127.0.0.1:49154->8443/tcp, 127.0.0.1:49153->32443/tcp   minikube
e63ced19d9fe   004811815584                          "etcd --advertise-cl…"   5 weeks ago     Up 5 weeks                                                                                                                                           k8s_etcd_etcd-lahdev_kube-system_3841c848f0ac3f17e24aa760021629e8_33
aeba1f295a07   c7ab721dfdae                          "kube-controller-man…"   5 weeks ago     Up 5 weeks                                                                                                                                           k8s_kube-controller-manager_kube-controller-manager-lahdev_kube-system_e6b4c4a24f2fb437953a574c1b4449c7_6
42d66310ac9f   d4893b67e97f                          "kube-scheduler --au…"   5 weeks ago     Up 5 weeks                                                                                                                                           k8s_kube-scheduler_kube-scheduler-lahdev_kube-system_22204fa289db49368e406d46ad18bb8d_11
a1ba54b0b7ff   k8s.gcr.io/pause:3.5                  "/pause"                 5 weeks ago     Up 5 weeks                                                                                                                                           k8s_POD_etcd-lahdev_kube-system_3841c848f0ac3f17e24aa760021629e8_5
9e03bef7fac3   k8s.gcr.io/pause:3.5                  "/pause"                 5 weeks ago     Up 5 weeks                                                                                                                                           k8s_POD_kube-controller-manager-lahdev_kube-system_e6b4c4a24f2fb437953a574c1b4449c7_4
35440fbb7535   k8s.gcr.io/pause:3.5                  "/pause"                 5 weeks ago     Up 5 weeks                                                                                                                                           k8s_POD_kube-scheduler-lahdev_kube-system_22204fa289db49368e406d46ad18bb8d_4
f6007657359b   k8s.gcr.io/pause:3.5                  "/pause"                 5 weeks ago     Up 5 weeks                                                                                                                                           k8s_POD_kube-apiserver-lahdev_kube-system_c8dff736dc97abf00f5e3814bab21602_4
```

- 클러스터 구성을 위해 kubelet이라는 에이전트가 모든 노드에서 실행됨
- kubelet은 컨테이너의 생성, 삭제 뿐만 아니라 노드 간 통신 역할도 담당

### 6.2 포드(Pod): 컨테이너를 다루는 기본 단위

- 컨테이너 애플리케이션 구동을 위해 반드시 알아야 할 오브젝트: Pod, Replica Set, Service, Deployment

#### 6.2.1 포드 사용하기

- 컨테이너 애플리케이션의 기본 단위
- 1개 이상의 컨테이너로 구성된 컨테이너의 집합

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-nginx-pod
spec:
  containers:
  - name: my-nginx-container
    image: nginx:latest
    ports:
    - containerPort: 80
      protocol: TCP
```

- apiVersion: 오브젝트의 API 버전 (사용하려는 오브젝트에 따라 달라질 수 있음)
- kind: 리소스 오브젝트 종류
- metadata: 라벨, 주석, 이름과 같은 부가 정보
- spec: 리소스를 생성하기 위한 자세한 정보

```bash
[root@lahdev study]# kubectl apply -f nginx-pod.yaml
pod/my-nginx-pod created
[root@lahdev study]# kubectl get pods
NAME           READY   STATUS    RESTARTS   AGE
my-nginx-pod   1/1     Running   0          25s
[root@lahdev study]# kubectl describe pods my-nginx-pod
Name:         my-nginx-pod
Namespace:    default
Priority:     0
Node:         minikube/192.168.49.2
Start Time:   Wed, 21 Feb 2024 18:22:35 +0900
Labels:       <none>
Annotations:  <none>
Status:       Running
IP:           10.244.0.3
IPs:
  IP:  10.244.0.3
...중략
```

- IP는 클러스터 내부에서만 접근할 수 있기 때문에 클러스터 내부로 들어간 후 요청해야함
- 다음 명령어로 임시 이미지를 통해 클러스터 내부로 들어갈 수 있는 임시 포드를 생성&접근 후 테스트가 가능

```bash
[root@lahdev study]# kubectl run -i --tty --rm debug --image=alicek106/ubuntu:curl --restart=Never bash
If you don't see a command prompt, try pressing enter.
root@debug:/#
root@debug:/# curl 10.244.0.3
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
root@debug:/#
```

- docker exec 명령어와 유사하게 kubectl exec 명령어로 포드의 컨테이너에 명령어를 전달할 수 있음
- 오브젝트 삭제시 delete -f 명령어로 삭제 가능 (pod 이름도 사용 가능)

```bash
[root@lahdev study]# kubectl exec -it my-nginx-pod bash
kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.
root@my-nginx-pod:/# ls /etc/nginx
conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params
root@my-nginx-pod:/# exit
[root@lahdev study]# kubectl delete -f nginx-pod.yaml
pod "my-nginx-pod" deleted
[root@lahdev study]#
```

#### 6.2.2 포드 vs. 도커 컨테이너

- 도커 컨테이너와 포드는 사용해보면 매우 비슷한데 왜 새로운 개념이 필요할까?
- 다음 결과에서 1/1이라는 항목에서 알 수 있듯이, 포드는 반드시 1개의 컨테이너로 구성되는 것이 아님

```bash
[root@lahdev study]# kubectl get pods
NAME           READY   STATUS    RESTARTS   AGE
my-nginx-pod   1/1     Running   0          25s
```

- 기존 YAML에 새 컨테이너를 추가하여 실행해보자

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-nginx-pod
spec:
  containers:
  - name: my-nginx-container
    image: nginx:latest
    ports:
    - containerPort: 80
      protocol: TCP
  - name: ubuntu-sidecar-container
    image: alicek106/rr-test:curl
    command: ["tail"]
    args: ["-f", "/dev/null"]
```

```bash
[root@lahdev study]# kubectl apply -f nginx-pod.yaml
pod/my-nginx-pod created
[root@lahdev study]# kubectl get pods
NAME           READY   STATUS    RESTARTS   AGE
my-nginx-pod   2/2     Running   0          12s
[root@lahdev study]#
[root@lahdev study]# kubectl exec -it my-nginx-pod -c ubuntu-sidecar-container bash
kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.
root@my-nginx-pod:/# curl localhost
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
root@my-nginx-pod:/#
```

- ubuntu-sidecar-container 컨테이너에 들어가서 로컬호스트로 HTTP 요청을 전송하면 Nginx 서버의 응답이 도착하는 것을 확인할 수 있음
- 즉, 같은 리눅스 네임스페이스를 공유하기 때문에 가능.

![같은 포드 내의 컨테이너는 네트워크 네임스페이스를 공유](./assets/img3.png?raw=true)

- 공유하는 리눅스 네임스페이스는 네트워크 환경만 있는 것은 아니지만, 나중에 다룸

#### 6.2.3 완전한 애플리케이션으로서의 포드

- 하나의 포드는 하나의 완전한 애플리케이션
- Nginx 컨테이너는 그 자체만으로도 완전한 애플리케이션. 따라서 하나의 포드에 2개의 Nginx 컨테이너가 정의되는 것은 바람직하지 않음
- 만약 부가적인 기능이 필요하다면?
  - 설정을 재구성해주는 reloader 프로세스
  - 로그를 수집하는 프로세스 등
  - 이러한 프로세스는 Nginx 컨테이너와 함께 실행되어야 함
- 포드의 주 컨테이너는 Nginx
- 기능 확장을 위한 추가 컨테이너를 포함시킬 수 있음: 사이드카 컨테이너

### 6.3 레플리카셋(Replica Set): 일정 개수의 포드를 유지하는 컨트롤러

#### 6.3.1 레플리카셋을 사용하는 이유

- 포드만 정의해서 생성하면 포드의 LifeCycle은 어떻게 될까?
  - kubectl delete 명령어로 포드를 삭제하면 포드의 컨테이너와 포드가 전부 삭제됨
  - 즉, 포드만 정의하는 경우 포드는 사용자에 의해서만 관리됨
  - 스웜 모드에서 다뤘던 것처럼 여러 개의 동일한 컨테이너를 생성하고 분배하고 싶다면?
- 포드를 여러개 생성해 분배할 수 있어야 함

![같은 포드 내의 컨테이너는 네트워크 네임스페이스를 공유](./assets/img4.png?raw=true)

- YAML 파일에 ---를 구분자로 사용하여 여러 개의 리소스를 정의할 수 있으나 매우 비효율
- 따라서 포드만 정의해서 사용하지 않고, 레플리카셋을 통해 보완

##### 레플리카셋 역할

- 정해진 수의 동일한 포드가 항상 실행되도록 관리
- 노드 장애 등의 이유로 포드를 사용할 수 없다면 다른 노드에서 포드를 다시 생성

#### 6.3.2 레플리카셋 사용하기
